{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"XCTL - A tool for managing a Kubernetes based infrastructure \u00b6 Get started XCTL is a tool that leverages CNCF technology to bootstrap and handle a production grade environment. Warning This software is not ready for actual production usage xctl apply -f - << EOF apiVersion: v1alpha1 kind: Environment metadata: name: demo email: demo@example.com spec: provider: linode domain: example.com repository: git@github.com:example-org/example-app.git EOF will result in an environment consisting of the following technologies: Kubernetes for resource orchestration NGINX Ingress Controller for traffic routing Cert-Manager configured with Let's encrypt for TLS Grafana , Prometheus , Loki and Promtail for monitoring ArgoCD for continuous deployment div.buttons { width: 100%; display: flex; justify-content: center; margin-bottom: 2em; } div.technologies-container { display: grid; grid-template-columns: 50% 50%; } div.technology { display: flex; align-items: center; margin-top: 1em; } img.icon { max-width: 48px; max-height: 48px; min-height: 48px; } span.content { margin-left: 1em; }","title":"XCTL - A tool for managing a Kubernetes based infrastructure"},{"location":"#xctl-a-tool-for-managing-a-kubernetes-based-infrastructure","text":"Get started XCTL is a tool that leverages CNCF technology to bootstrap and handle a production grade environment. Warning This software is not ready for actual production usage xctl apply -f - << EOF apiVersion: v1alpha1 kind: Environment metadata: name: demo email: demo@example.com spec: provider: linode domain: example.com repository: git@github.com:example-org/example-app.git EOF will result in an environment consisting of the following technologies: Kubernetes for resource orchestration NGINX Ingress Controller for traffic routing Cert-Manager configured with Let's encrypt for TLS Grafana , Prometheus , Loki and Promtail for monitoring ArgoCD for continuous deployment div.buttons { width: 100%; display: flex; justify-content: center; margin-bottom: 2em; } div.technologies-container { display: grid; grid-template-columns: 50% 50%; } div.technology { display: flex; align-items: center; margin-top: 1em; } img.icon { max-width: 48px; max-height: 48px; min-height: 48px; } span.content { margin-left: 1em; }","title":"XCTL - A tool for managing a Kubernetes based infrastructure"},{"location":"application/manifest/","text":"Application manifest \u00b6 Below is a list of all configuration attributes for an environment manifest. apiVersion * \u00b6 required Type Example Description string v1alpha1 Defines the version of the schema. kind * \u00b6 required Type Example Description string Application Defines the kind of the schema. metadata \u00b6 name * \u00b6 required Type Regex Example Description string [a-z]+(-[a-z]+){0,2} hello-world Defines the name of the application. spec \u00b6 image * \u00b6 required Type Example Description string ghcr.io/tuuturu/xctl-hello Defines the URI of the container image to be used in the application. port \u00b6 Type Example Default Description number 80 None Defines the port your application listens to traffic on. Only required if the application expects traffic. url \u00b6 Type Example Default Description string hello.tuuturu.org None Defines the URL your application will be available on. Only required if the application should be available outside the cluster. metrics \u00b6 Type Example Default Description string /metrics None Defines the path of your application which exposes metric data span.required { color: red; } div.md-typeset__table { width: 100%; }","title":"Manifest reference"},{"location":"application/manifest/#application-manifest","text":"Below is a list of all configuration attributes for an environment manifest.","title":"Application manifest"},{"location":"application/manifest/#apiversion","text":"required Type Example Description string v1alpha1 Defines the version of the schema.","title":"apiVersion*"},{"location":"application/manifest/#kind","text":"required Type Example Description string Application Defines the kind of the schema.","title":"kind*"},{"location":"application/manifest/#metadata","text":"","title":"metadata"},{"location":"application/manifest/#name","text":"required Type Regex Example Description string [a-z]+(-[a-z]+){0,2} hello-world Defines the name of the application.","title":"name*"},{"location":"application/manifest/#spec","text":"","title":"spec"},{"location":"application/manifest/#image","text":"required Type Example Description string ghcr.io/tuuturu/xctl-hello Defines the URI of the container image to be used in the application.","title":"image*"},{"location":"application/manifest/#port","text":"Type Example Default Description number 80 None Defines the port your application listens to traffic on. Only required if the application expects traffic.","title":"port"},{"location":"application/manifest/#url","text":"Type Example Default Description string hello.tuuturu.org None Defines the URL your application will be available on. Only required if the application should be available outside the cluster.","title":"url"},{"location":"application/manifest/#metrics","text":"Type Example Default Description string /metrics None Defines the path of your application which exposes metric data span.required { color: red; } div.md-typeset__table { width: 100%; }","title":"metrics"},{"location":"environment/continuous-deployment/","text":"Accessing ArgoCD \u00b6 First, acquire credentials for ArgoCD by running the get credentials command: xctl --context env.yaml get credentials argocd After you've gotten the credentials, open a tunnel to the ArgoCD instance by running the following command: xctl --context env.yaml forward argocd Bootstrapped ArgoCD applications \u00b6 Applications \u00b6 This ArgoCD application tracks the /infrastructure/<environment name>/argocd/applications/ directory. This directory contains ArgoCD applications referencing actual applications. This setup has the following effects: We can deploy a new application without administrating the environment directly by adding an ArgoCD application manifest to this directory This renders the ArgoCD setup stateless, meaning we can upgrade ArgoCD by toggling the integration off and on again in the environment.yaml manifest. Namespaces \u00b6 The namespaces ArgoCD application tracks the /infrastructure/<environment name>/argocd/namespaces/ directory. This directory contains Kubernetes manifests defining all namespaces in the cluster. This lets us disassociate a namespace from an application, allowing namespaces to outlive an application in the case where multiple applications reside in the same namespace, but one is deleted.","title":"Continuous deployment"},{"location":"environment/continuous-deployment/#accessing-argocd","text":"First, acquire credentials for ArgoCD by running the get credentials command: xctl --context env.yaml get credentials argocd After you've gotten the credentials, open a tunnel to the ArgoCD instance by running the following command: xctl --context env.yaml forward argocd","title":"Accessing ArgoCD"},{"location":"environment/continuous-deployment/#bootstrapped-argocd-applications","text":"","title":"Bootstrapped ArgoCD applications"},{"location":"environment/continuous-deployment/#applications","text":"This ArgoCD application tracks the /infrastructure/<environment name>/argocd/applications/ directory. This directory contains ArgoCD applications referencing actual applications. This setup has the following effects: We can deploy a new application without administrating the environment directly by adding an ArgoCD application manifest to this directory This renders the ArgoCD setup stateless, meaning we can upgrade ArgoCD by toggling the integration off and on again in the environment.yaml manifest.","title":"Applications"},{"location":"environment/continuous-deployment/#namespaces","text":"The namespaces ArgoCD application tracks the /infrastructure/<environment name>/argocd/namespaces/ directory. This directory contains Kubernetes manifests defining all namespaces in the cluster. This lets us disassociate a namespace from an application, allowing namespaces to outlive an application in the case where multiple applications reside in the same namespace, but one is deleted.","title":"Namespaces"},{"location":"environment/manifest/","text":"Environment manifest \u00b6 Below is a list of all configuration attributes for an environment manifest. apiVersion * \u00b6 required Type Example Description string v1alpha1 Defines the version of the schema. kind * \u00b6 required Type Example Description string Environment Defines the kind of the schema. metadata \u00b6 name * \u00b6 required Type Regex Example Description string [a-z]+(-[a-z]+){0,2} tuuturu-production Defines the name of the environment. email * \u00b6 required Type Example Description string xctl@example.com Defines the email associated with the environment. Currently, only used for registering SSL certificates with Let's Encrypt. spec \u00b6 provider * \u00b6 Type Example Description string linode Defines the cloud provider to use for the environment domain * \u00b6 Type Example Description string tuuturu.org Defines the associated domain for the environment. Xctl will attempt to add a wildcard record to this domain pointing it to the node balancer. plugins \u00b6 nginxIngressController \u00b6 Type Default Helm Description boolean true chart Handles traffic into the environment cert-manager \u00b6 Type Default Helm Description boolean true chart Generates SSL certificates on demand grafana \u00b6 Type Default Helm Description boolean true chart Visualises metrics, logs, traces prometheus \u00b6 Type Default Helm Description boolean true chart Stores and exposes metrics data loki \u00b6 Type Default Helm Description boolean true chart Stores and exposes log data promtail \u00b6 Type Default Helm Description boolean true chart Scrapes logs and pushes them to Loki span.required { color: red; } div.md-typeset__table { width: 100%; }","title":"Manifest reference"},{"location":"environment/manifest/#environment-manifest","text":"Below is a list of all configuration attributes for an environment manifest.","title":"Environment manifest"},{"location":"environment/manifest/#apiversion","text":"required Type Example Description string v1alpha1 Defines the version of the schema.","title":"apiVersion*"},{"location":"environment/manifest/#kind","text":"required Type Example Description string Environment Defines the kind of the schema.","title":"kind*"},{"location":"environment/manifest/#metadata","text":"","title":"metadata"},{"location":"environment/manifest/#name","text":"required Type Regex Example Description string [a-z]+(-[a-z]+){0,2} tuuturu-production Defines the name of the environment.","title":"name*"},{"location":"environment/manifest/#email","text":"required Type Example Description string xctl@example.com Defines the email associated with the environment. Currently, only used for registering SSL certificates with Let's Encrypt.","title":"email*"},{"location":"environment/manifest/#spec","text":"","title":"spec"},{"location":"environment/manifest/#provider","text":"Type Example Description string linode Defines the cloud provider to use for the environment","title":"provider*"},{"location":"environment/manifest/#domain","text":"Type Example Description string tuuturu.org Defines the associated domain for the environment. Xctl will attempt to add a wildcard record to this domain pointing it to the node balancer.","title":"domain*"},{"location":"environment/manifest/#plugins","text":"","title":"plugins"},{"location":"environment/manifest/#nginxingresscontroller","text":"Type Default Helm Description boolean true chart Handles traffic into the environment","title":"nginxIngressController"},{"location":"environment/manifest/#cert-manager","text":"Type Default Helm Description boolean true chart Generates SSL certificates on demand","title":"cert-manager"},{"location":"environment/manifest/#grafana","text":"Type Default Helm Description boolean true chart Visualises metrics, logs, traces","title":"grafana"},{"location":"environment/manifest/#prometheus","text":"Type Default Helm Description boolean true chart Stores and exposes metrics data","title":"prometheus"},{"location":"environment/manifest/#loki","text":"Type Default Helm Description boolean true chart Stores and exposes log data","title":"loki"},{"location":"environment/manifest/#promtail","text":"Type Default Helm Description boolean true chart Scrapes logs and pushes them to Loki span.required { color: red; } div.md-typeset__table { width: 100%; }","title":"promtail"},{"location":"environment/monitoring/","text":"Accessing Grafana \u00b6 First, acquire credentials for Grafana by running the get credentials command: xctl --context env.yaml get credentials grafana After you've gotten the credentials, open a tunnel to the Grafana instance by running the following command: xctl --context env.yaml forward grafana Viewing logs \u00b6 To view logs, first click on the explore button in the menu on the left side of the screen. Make sure you select \"Loki\" as the datasource. Follow the steps in the query builder and click \"Show logs\". Check out the LogQL documentation for more information on how to use the log query interface. Viewing metrics \u00b6 To view metrics, first click on the explore button in the menu on the left side of the screen. Make sure you select \"Prometheus\" as the datasource. To find certain metrics you can click the dropdown button to the left of the query field to select relevant metrics. Check out the LogQL documentation for more information on how to use the metric query interface.","title":"Monitoring"},{"location":"environment/monitoring/#accessing-grafana","text":"First, acquire credentials for Grafana by running the get credentials command: xctl --context env.yaml get credentials grafana After you've gotten the credentials, open a tunnel to the Grafana instance by running the following command: xctl --context env.yaml forward grafana","title":"Accessing Grafana"},{"location":"environment/monitoring/#viewing-logs","text":"To view logs, first click on the explore button in the menu on the left side of the screen. Make sure you select \"Loki\" as the datasource. Follow the steps in the query builder and click \"Show logs\". Check out the LogQL documentation for more information on how to use the log query interface.","title":"Viewing logs"},{"location":"environment/monitoring/#viewing-metrics","text":"To view metrics, first click on the explore button in the menu on the left side of the screen. Make sure you select \"Prometheus\" as the datasource. To find certain metrics you can click the dropdown button to the left of the query field to select relevant metrics. Check out the LogQL documentation for more information on how to use the metric query interface.","title":"Viewing metrics"},{"location":"getting-started/apply-application/","text":"Deploy an application \u00b6 Configure \u00b6 First, scaffold an application configuration file by running the following command: xctl scaffold application > application.yaml Configure the application as required. Note A full list of available configuration parameters can be found here Deploy \u00b6 Generate necessary Kubernetes and ArgoCD configuration by running the following command: xctl apply --file application.yaml --context environment.yaml After you've configured the generated files, commit and push the changes. Tip To avoid having to specify the environment context for contextual commands, use xctl venv","title":"Deploy application"},{"location":"getting-started/apply-application/#deploy-an-application","text":"","title":"Deploy an application"},{"location":"getting-started/apply-application/#configure","text":"First, scaffold an application configuration file by running the following command: xctl scaffold application > application.yaml Configure the application as required. Note A full list of available configuration parameters can be found here","title":"Configure"},{"location":"getting-started/apply-application/#deploy","text":"Generate necessary Kubernetes and ArgoCD configuration by running the following command: xctl apply --file application.yaml --context environment.yaml After you've configured the generated files, commit and push the changes. Tip To avoid having to specify the environment context for contextual commands, use xctl venv","title":"Deploy"},{"location":"getting-started/apply-environment/","text":"Create an environment \u00b6 Configure \u00b6 First, scaffold an environment configuration file by running the following command: xctl scaffold environment > environment.yaml Configure the environment as required. Note A full list of available configuration parameters can be found here Authenticate \u00b6 To authenticate with the relevant services for your environment, run the following command: xctl login --context environment.yaml Create \u00b6 To create an environment based on the configuration file, run the following command: xctl apply --file environment.yaml After a few minutes, you'll have a production grade environment ready to be used.","title":"Create environment"},{"location":"getting-started/apply-environment/#create-an-environment","text":"","title":"Create an environment"},{"location":"getting-started/apply-environment/#configure","text":"First, scaffold an environment configuration file by running the following command: xctl scaffold environment > environment.yaml Configure the environment as required. Note A full list of available configuration parameters can be found here","title":"Configure"},{"location":"getting-started/apply-environment/#authenticate","text":"To authenticate with the relevant services for your environment, run the following command: xctl login --context environment.yaml","title":"Authenticate"},{"location":"getting-started/apply-environment/#create","text":"To create an environment based on the configuration file, run the following command: xctl apply --file environment.yaml After a few minutes, you'll have a production grade environment ready to be used.","title":"Create"},{"location":"getting-started/delete-application/","text":"Delete an application \u00b6 To delete an application, run the following command: xctl delete --file application.yaml --context environment.yaml Commit and push to finalize the changes. Tip To avoid having to specify the environment context for contextual commands, use xctl venv","title":"Delete application"},{"location":"getting-started/delete-application/#delete-an-application","text":"To delete an application, run the following command: xctl delete --file application.yaml --context environment.yaml Commit and push to finalize the changes. Tip To avoid having to specify the environment context for contextual commands, use xctl venv","title":"Delete an application"},{"location":"getting-started/delete-environment/","text":"Delete an environment \u00b6 To delete an environment, run the following command: xctl delete --file environment.yaml After a few minutes, your environment will be deleted.","title":"Delete environment"},{"location":"getting-started/delete-environment/#delete-an-environment","text":"To delete an environment, run the following command: xctl delete --file environment.yaml After a few minutes, your environment will be deleted.","title":"Delete an environment"},{"location":"getting-started/preparation/","text":"Install XCTL \u00b6 Prerequisites \u00b6 Go 1.17 Linode account Github account Installation \u00b6 # First clone the repository git clone git@github.com:tuuturu/xctl.git && cd xctl # Build xctl make build # Install xctl make install This will install xctl into your ~/.local/bin folder. Note Remember to add ~/.local/bin to your path by adding export PATH=$PATH:~/.local/bin to your ~/.bashrc equivalent. To modify where the script installs xctl , use INSTALL_DIR=<new directory> . For example: INSTALL_DIR = ~/.local/binaries make install That should be it. xctl should now be available. Test by running a command. For example: xctl --version","title":"Setup"},{"location":"getting-started/preparation/#install-xctl","text":"","title":"Install XCTL"},{"location":"getting-started/preparation/#prerequisites","text":"Go 1.17 Linode account Github account","title":"Prerequisites"},{"location":"getting-started/preparation/#installation","text":"# First clone the repository git clone git@github.com:tuuturu/xctl.git && cd xctl # Build xctl make build # Install xctl make install This will install xctl into your ~/.local/bin folder. Note Remember to add ~/.local/bin to your path by adding export PATH=$PATH:~/.local/bin to your ~/.bashrc equivalent. To modify where the script installs xctl , use INSTALL_DIR=<new directory> . For example: INSTALL_DIR = ~/.local/binaries make install That should be it. xctl should now be available. Test by running a command. For example: xctl --version","title":"Installation"}]}